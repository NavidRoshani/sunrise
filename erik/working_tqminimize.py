import tequila as tq
import sunrise as sun
from sunrise.expval.tcc_expval import TCCBraket
import numpy as np
from openfermion import FermionOperator

geom = "H 0.0 0.0 0.0\nH 0.0 0.0 1.6"#\nH 0. 0. 3.2\nH 0. 0. 4.8"
backend = 'tcc'
mol = tq.Molecule(geometry=geom,basis_set='sto-3g',transformation='reordered-jordan-wigner')
smol = sun.molecules.HyMolecule(geometry=geom,basis_set='sto-3g',transformation='reordered-jordan-wigner')
fmol = sun.molecules.FerMolecule(geometry=geom,basis_set='sto-3g')
print('HF ',mol.compute_energy('HF'))
mol = mol.use_native_orbitals()
edges = smol.get_spa_edges()
# guess = smol.get_spa_guess()
# U = mol.make_ansatz('hcb-spa',edges=edges)
U = mol.make_ansatz('spa',edges=edges)
# U = mol.make_ansatz('spa',edges=edges,optimize=False)
circuit = sun.FCircuit.from_edges(edges,n_orb=mol.n_orbitals)
print(tq.simulate(U,variables={d:0.1 for d in U.extract_variables()}))
print(sun.simulate(circuit,variables={d:0.1 for d in circuit.extract_variables()},mol=mol))
H = mol.make_hamiltonian()
opt = tq.chemistry.optimize_orbitals(molecule=mol,circuit=U,use_hcb=False,silent=True)
print(opt.energy)
opt = sun.optimize_orbitals(fmol,circuit=circuit,backend='tcc',silent=True)
print(opt.energy)
exit()
# mol = opt.molecule
# print(h)
# print(mol.integral_manager.one_body_integrals)
# print(mol.integral_manager.orbital_coefficients.dot(mol.integral_manager.one_body_integrals))
# exit()
# U = mol.make_ansatz("UpCCSD",hcb_optimization=False) #could be hcb-optimized but the from_Qcircuit doesnt work
# circuit = sun.FCircuit.from_Qcircuit(U)
# tq.show_available_simulators()
# a = tq.Variable("a")
# circuit = sun.gates.UC(0,1,"c")
# circuit += sun.gates.UR(0,1,a)
# circuit += sun.gates.UR(2,3,2*a)
# circuit.initial_state =  mol.prepare_reference()
# U += tq.gates.I([9,10])
# print(circuit)
# print(fmol.make_hamiltonian())
# print(fmol.make_uccsd_ansatz())
# sunval:TCCBraket = sun.Braket(molecule=mol,circuit=circuit,backend=backend,operator='I',backend_kwargs={'backend':'numpy','engine':'pyscf'})

# op = [FermionOperator('2^ 0^ 2 0',1.) , FermionOperator('2^ 1^ 3 0',1.),FermionOperator('3^ 0^ 2 1',1.),FermionOperator('3^ 1^ 3 1',1.)]
# # op = FermionOperator('0^  0',0.5) +FermionOperator('1^  1',0.5) 
# for p in op:
#     qop = mol.transformation(p)
#     real, imag = qop.split(hermitian=True)
#     print(tq.simulate(tq.ExpectationValue(H=real ,U=U),variables={d:0.1 for d in U.extract_variables()}))
# for p in op:
#     print(sun.simulate(sun.Braket(backend='tcc',operator=p,U=circuit,mol=mol),variables={d:0.1 for d in circuit.extract_variables()}))
# op = sum(op)
# op = FermionOperator('2^ 0^ 2 0',1.)
# print(op)
# qop = mol.transformation(op)
# print(qop)
# real, imag = qop.split(hermitian=True)
# print(tq.simulate(tq.ExpectationValue(H=real ,U=U),variables={d:0.1 for d in U.extract_variables()}))
# # op = FermionOperator('0^  0',0.5) +FermionOperator('1^  1',0.5) 
# # op = FermionOperator('0^ 1^ 1 0',1.) + FermionOperator('1^ 0^ 0 1',1.)
# print(sun.simulate(sun.Braket(backend='tcc',operator=op,U=circuit,mol=mol),variables={d:0.1 for d in circuit.extract_variables()}))
# exit()
# srdm1,srdm2 = fmol.compute_rdms(U=circuit,variables={d:0.1 for d in circuit.extract_variables()},backend='tcc')
# # print(srdm1)
# # print(srdm2)
# trdm1,trdm2 = mol.compute_rdms(U=U,variables={d:0.1 for d in U.extract_variables()})
# # print(trdm1)
# # print(trdm2)
# print(np.allclose(srdm1,trdm1))
# print(np.allclose(srdm2,trdm2))
# print('tq\n',trdm2[0])
# print('sn\n',srdm2[0])
# print('------')
# print('tq\n',trdm2[1])
# print('sn\n',srdm2[1])
# diff = np.where(~np.isclose(srdm2,trdm2))
# print(diff)
# print('tq\n',trdm2[diff])
# print('sn\n',srdm2[diff])
# print(np.where(np.isclose(srdm2,3.98001666)))
# diff = np.argwhere(~np.isclose(srdm2,trdm2))
# print(diff)
exit()

# mol = sun.optimize_orbitals(molecule=mol,circuit=circuit,backend='tcc')
# print(mol.energy)
# print(opt.energy)
# print(U)
# print(U.qubits)
# I = mol.prepare_reference()
# print('--',I.n_qubits)
# ini = tq.simulate(mol.prepare_reference())
# print(ini)
# print(ini.n_qubits)
# print(type(bin(1000)[2:]))
# print((bin(1000)[2:]))
# print(type(int(bin(1000)[2:])))
# print((int(bin(1000)[2:])))

# ini.n_qubits = max(U.n_qubits,ini.n_qubits)
# U.n_qubits = max(U.n_qubits,ini.n_qubits)
# ini = tq.simulate(mol.prepare_reference()).to_array()
# ini = '+1.0000|1000010000>'
# ini = 1100011000 #NOTE THIS WORKS
# ini = {1.:1100011000} 
# ini = [1100011000,1010010100]
# print(tq.simulate(U,initial_state=ini,variables={'a':0.5,'c':0.5}))

# print(sun.simulate(circuit,variables={'a':0.5,'c':0.5}))
#TODO: remember to change tencirchem.static.evolve_civector.py.get_operators
# l = circuit.initial_state.to_array()
# print(f''.join(f'{l[i]}|{bin(i)[2:]}>'.format() for i in np.where(l>1.e-6)[0]))
# print('tq ',U.make_parameter_map())
# print('tq ',U.extract_variables())
# print('sun ',circuit.make_parameter_map())
expval = tq.ExpectationValue(H=mol.make_hardcore_boson_hamiltonian(),U=U)
# print(expval.args)
# print(expval.args[0].args)
c,h,g = mol.get_integrals()
# sunval:TCCBraket = sun.Braket(c=c,h=h,g=g,n_elec=mol.n_electrons,circuit=circuit,backend=backend)#,backend_kwargs={'backend':'numpy','engine':'pyscf'})
# sunval:TCCBraket = sun.Braket(molecule=mol,circuit=circuit,backend=backend,backend_kwargs={'backend':'numpy','engine':'pyscf'})
sunval:TCCBraket = sun.Braket(molecule=mol,circuit=circuit,backend=backend)#,backend_kwargs={'backend':'numpy','engine':'pyscf'})
# from tencirchem import Op
# from tencirchem.utils.misc import ex_op_to_fop
# # H = Op('a^\dagger a',[0,1])
# H = ex_op_to_fop([0,1])
# print(H)
# BK = sunval.BK
print(sunval({d:0.1 for d in sunval.extract_variables()}))
sunval:TCCBraket = sun.Braket(molecule=mol,circuit=circuit,backend=backend,operator='I',backend_kwargs={'backend':'numpy','engine':'pyscf'})
print(sunval({d:0.1 for d in sunval.extract_variables()}))
# print(BK.energy([0.1,0.1],hamiltonian=H,engine='pyscf'))
# from tencirchem import HEA
# from tencirchem.static.hea import fop_to_qop
# from openfermion import QubitOperator
# from openfermion.linalg.sparse_tools import get_sparse_operator
# h_qubit_op = mol.make_hamiltonian()
# qubitH = QubitOperator(f''.join(f'Z{i} ' for i in range(2*mol.n_orbitals)))
# th_qubit_op = QubitOperator()
# for k, v in qubitH.terms.items():
#     if not np.iscomplex(v):
#         v = v.real
#     th_qubit_op.terms[k] = v
# H = np.array(get_sparse_operator(th_qubit_op,2*mol.n_orbitals).todense())
# H = [*get_sparse_operator(th_qubit_op,2*mol.n_orbitals).todense()]
# print(BK.energy([0.1,0.1],hamiltonian=H,engine='pyscf'))
exit()
# print(sunval)
# print(sunval.BK.ex_ops_ket)
# print(sunval.ket)
# print(sunval([0. for _ in sunval.BK.variables]))
# print(tq.simulate(a,variables={"a":0.5,"c":0.5}))
# exit()
# print(tq.minimize(a))
# exit()
# print(a)
# a = 2*a + a
# print(2*a+a)
# print(sunval.grad('a'))
# print(tq.simulate(a,variables={"a":0.,'c':0.}))
# print(vars(a))
# print(vars(2*a+a))
# g = sun.grad(a,"a")
# print(g)
# print(g.args)
# print(sun.grad(a))
# print(sun.grad(expval))
print('KET',sunval.ket,'\n------------------------------------------------------')
print(sunval.BK.ex_ops_ket)
v = expval.extract_variables()
# print('tq',tq.simulate(expval,variables={d:0. for d in v}))
# print('sn',sun.simulate(sunval,variables={d:0. for d in v}))
# print('tq',tq.simulate(expval,variables={d:0.2 for d in v}))
# print('sn',sun.simulate(sunval,variables={d:0.1 for d in v}))

# g = sun.grad(sunval,v[1])
# for e,i in enumerate(g.args):
#     print(e,'->',sun.simulate(i,{d:0.1 for d in v}))
# print(g.args[0].BK.ex_ops_ket)
# print(g.args[0].BK.ex_ops_bra)
# print(g.args[0].ket)
# print(g.args[0].bra)
# print('tq',tq.simulate(tq.grad(expval,v[0]),variables={d:0.1 for d in v}))
# print('tq',tq.simulate(tq.grad(expval,v[1]),variables={d:0.1 for d in v}))
# print('sn',tq.simulate(sun.grad(sunval,v[0]),variables={d:0.1 for d in v}))
# print('sn',tq.simulate(sun.grad(sunval,v[1]),variables={d:0.1 for d in v}))
rex = sun.minimize(sunval,silent=True)
trex = tq.minimize(expval,silent=True)
print('SN',rex.energy)
print('SN',rex.variables)
print('tq',trex.energy)
print('tq',trex.variables)
# sunval.grad()
# print(sunval.ket)
